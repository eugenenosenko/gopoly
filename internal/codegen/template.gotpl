package {{ .Package }}

import (
    "bytes"
    "encoding/json"
    "fmt"
{{- if .Imports }}
{{ range $i := .Imports }}
    {{ if $i.Aliased }}{{ printf "%s " $i.ShortName }}{{- end -}}{{printf "%q" $i.Path}}
{{- end }}
{{- end }}
)

{{- define "unmarshalers" -}}
{{ range $d, $variant := .Variants }}
{{- if $variant.Fields }}

// UnmarshalJSON JSON marshaler implementations for {{ $variant.Name }} containing polymorphic fields.
func (v *{{ $variant.Name }}) UnmarshalJSON(b []byte) error {
	var data struct {
		{{ $variant.Name }}
	{{- range $field := $variant.Fields }}
		{{ if eq $field.Kind 0 }}{{ .Name }} json.RawMessage
		{{- else if eq $field.Kind 2 }}{{ .Name }} []json.RawMessage
		{{- else if eq $field.Kind 1 }}{{ .Name }} map[string]json.RawMessage
		{{- end -}}
		{{ $field.Tags }}
	{{- end }}
	}
	if err := json.Unmarshal(b, &data); err != nil {
		return fmt.Errorf("unmarshal {{ $variant.Name }}: %v", err)
	}
{{ range $field :=  $variant.Fields }}
{{- if eq $field.Kind 0 }}
	{{ lower $field.Name }}Field, err := {{ prefixed $field }}Unmarshal{{ $field.Interface.Name }}JSON(data.{{ $field.Name }})
	if err != nil {
		return fmt.Errorf("unmarshal {{ $variant.Name }}.{{ $field.Name }}: %v", err)
	}
{{ else if eq .Kind 2 }}
	{{ lower $field.Name }}Field := make([]{{ prefixed $field }}{{ $field.Interface.Name }}, len(data.{{ $field.Name }}))
	for i, r := range data.{{ $field.Name }} {
		v, err := {{ prefixed $field }}Unmarshal{{ $field.Interface.Name }}JSON(r)
		if err != nil {
			return fmt.Errorf("unmarshal {{ $variant.Name }}.{{ $field.Name }}[%d]: %v", i, err)
		}
		{{ lower $field.Name }}Field[i] = v
	}
{{ else if eq .Kind 1 }}
	{{ lower $field.Name }}Field := map[string]{{ prefixed $field }}{{ $field.Interface.Name }}{}
	for k, r := range data.{{ $field.Name }} {
		v, err := {{ prefixed $field }}Unmarshal{{ $field.Interface.Name }}JSON(r)
		if err != nil {
			return fmt.Errorf("unmarshal {{ $variant.Name }}.{{ $field.Name }}[%s]: %v", k, err)
		}
		{{ lower $field.Name }}Field[k] = v
	}
{{ end -}}
{{ end }}
	*v = data.{{ $variant.Name }}
	{{- range $field := $variant.Fields }}
	v.{{ $field.Name }} = {{ lower $field.Name }}Field
	{{- end }}
	return nil
}

var _ json.Unmarshaler = (*{{ $variant.Name }})(nil)
{{- end -}}
{{- end -}}
{{ end -}}

{{- define "discriminator" -}}
{{- with $type := . }}
func Unmarshal{{$type.Name}}JSON(data []byte) ({{$type.Name}}, error) {
	if len(data) == 0 || bytes.Equal(data, []byte("null")) {
		return nil, nil
	}
	var probe struct {
		Discriminator string `json:"{{$type.DiscriminatorField}}"`
	}
	if err := json.Unmarshal(data, &probe); err != nil {
		return nil, fmt.Errorf("unmarshal AdvertBase type: %w", err)
	}
	switch probe.Discriminator {
    {{- range $v, $type := $type.Variants }}
    case {{ printf "%q" $v}}:
        var v {{ $type.Name }}
        if err := json.Unmarshal(data, &v); err != nil {
            return nil, fmt.Errorf("unmarshal '{{$type.Name}}': %w", err)
        }
        return &v, nil
    {{- end}}
	default:
		return nil, fmt.Errorf("could not unmarshal '{{$type.Name}}': unknown variant %q", probe.Discriminator)
	}
}
{{- end }}
{{- end -}}

{{- define "strict" -}}
{{- with $type := . -}}
func Unmarshal{{$type.Name}}JSON(data []byte) ({{$type.Name}}, error) {
    newStrictDecoder := func(data []byte) *json.Decoder {
        dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        return dec
    }
    var err error
    matches := make([]{{ $type.Name }}, 0, {{ len $type.Variants }})
    {{- range $v, $type := $type.Variants }}
    var target{{ $type.Name }} {{ $type.Name }}
    // try to unmarshal data into {{$type.Name}}
    err = newStrictDecoder(data).Decode(&target{{ $type.Name }})
    if err == nil {
        asJSON, _ := json.Marshal(target{{ $type.Name }})
        if string(asJSON) != "{}" { // empty struct
            matches = append(matches, &target{{ $type.Name }})
        }
    }
    {{- end }}
    if len(matches) > 1 { // more than 1 match
        return nil, fmt.Errorf("data matches more than one of ({{$type.Name}})")
    } else if len(matches) == 1 {
        return matches[0], nil // exactly one match
    } else { // no match
        return nil, fmt.Errorf("failed to match data to one of ({{$type.Name}})")
    }
}
{{- end -}}
{{- end }}

{{- range $type := .Types }}
{{ if eq $type.DecodingStrategy "strict"}}
{{ template "strict" $type -}}
{{ else if eq $type.DecodingStrategy "discriminator" }}
{{- template "discriminator" $type}}
{{- end }}
{{- template "unmarshalers" $type}}
{{- end }}
