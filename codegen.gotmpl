// Code generated by gopoly. DO NOT EDIT.
package {{ .Package }}

import (
"bytes"
"encoding/json"
"fmt"
)
{{ range .RawAliases }}
    type rawjson{{ . }} {{ . }}
{{ end }}

{{- range $type := .Types }}
    // JSON marshaler implementations for {{ .Name }}.

    {{- range .Variants }}

        func (v {{ .Name }}) MarshalJSON() ([]byte, error) {
        return json.Marshal(struct {
        rawjson{{ .Name }}
        Kind string ` + "`json:\"{{ $type.Discriminant }}\"`" + `
        }{rawjson{{ .Name }}: rawjson{{ .Name }}(v), Kind: "{{ .JSONName }}"})
        }

        var _ json.Marshaler = {{ .Name }}{}
    {{- end  }}

    func Unmarshal{{ .Name }}JSON(b []byte) ({{ .Name }}, error) {
    if len(b) == 0 || bytes.Equal(b, []byte("null")) {
    return nil, nil
    }

    var probe struct {
    Kind string ` + "`json:\"{{ $type.Discriminant }}\"`" + `
    }
    if err := json.Unmarshal(b, &probe); err != nil {
    return nil, fmt.Errorf("unmarshal {{ .Name }} {{ $type.Discriminant }}: %v", err)
    }

    switch probe.Kind {
    {{- range .Variants }}
        case "{{ .JSONName }}":
        var v {{ .Name }}
        if err := json.Unmarshal(b, &v); err != nil {
        return nil, fmt.Errorf("unmarshal {{ .Name }}: %v", err)
        }
        return v, nil
    {{- end }}
    default:
    return nil, fmt.Errorf("could not unmarshal {{ .Name }} JSON: unknown variant %q", probe.Kind)
    }
    }
{{- end }}
{{ range $struct := .Structs }}
    // JSON marshaler implementations for {{ .Name }} containing polymorphic fields.

    func (v *{{ .Name }}) UnmarshalJSON(b []byte) error {
    var data struct {
    rawjson{{ .Name }}
    {{- range .PolymorphicFields }}

        {{ if eq .Kind "Scalar" }}{{ .Name }} json.RawMessage
        {{- else if eq .Kind "Slice" }}{{ .Name }} []json.RawMessage
        {{- else if eq .Kind "Map" }}{{ .Name }} map[string]json.RawMessage
        {{- end }}
        {{- with .JSONName }}` + " `json:\"{{ . }}\"`" + `{{ end }}
    {{- end }}
    }
    if err := json.Unmarshal(b, &data); err != nil {
    return fmt.Errorf("unmarshal {{ $struct.Name }}: %v", err)
    }
    {{ range .PolymorphicFields }}
        {{- if eq .Kind "Scalar" }}
            {{ lower .Name }}Field, err := Unmarshal{{ .Type }}JSON(data.{{ .Name }})
            if err != nil {
            return fmt.Errorf("unmarshal {{ $struct.Name }}.{{ .Name }}: %v", err)
            }
        {{- else if eq .Kind "Slice" }}
            {{ lower .Name }}Field := make([]{{ .Type }}, len(data.{{ .Name }}))
            for i, r := range data.{{ .Name }} {
            v, err := Unmarshal{{ .Type }}JSON(r)
            if err != nil {
            return fmt.Errorf("unmarshal {{ $struct.Name }}.{{ .Name }}[%d]: %v", i, err)
            }
            {{ lower .Name }}Field[i] = v
            }
        {{- else if eq .Kind "Map" }}
            {{ lower .Name }}Field := map[string]{{ .Type }}{}
            for k, r := range data.{{ .Name }} {
            v, err := Unmarshal{{ .Type }}JSON(r)
            if err != nil {
            return fmt.Errorf("unmarshal {{ $struct.Name }}.{{ .Name }}[%s]: %v", k, err)
            }
            {{ lower .Name }}Field[k] = v
            }
        {{- end }}
    {{- end }}

    *v = {{ .Name }}(data.rawjson{{ .Name }})
    {{- range .PolymorphicFields }}
        v.{{ .Name }} = {{ lower .Name }}Field
    {{- end }}
    return nil
    }

    func (v *{{ .Name }}) UnmarshalJSON(b []byte) error {
    var err error
    match := 0
    // try to unmarshal data into RentAdvert
    err = newStrictDecoder(data).Decode(&dst.RentAdvert)
    if err == nil {
    jsonRentAdvert, _ := json.Marshal(dst.RentAdvert)
    if string(jsonRentAdvert) == "{}" { // empty struct
    dst.RentAdvert = nil
    } else {
    match++
    }
    } else {
    dst.RentAdvert = nil
    }

    // try to unmarshal data into SellAdvert
    err = newStrictDecoder(data).Decode(&dst.SellAdvert)
    if err == nil {
    jsonSellAdvert, _ := json.Marshal(dst.SellAdvert)
    if string(jsonSellAdvert) == "{}" { // empty struct
    dst.SellAdvert = nil
    } else {
    match++
    }
    } else {
    dst.SellAdvert = nil
    }

    if match > 1 { // more than 1 match
    // reset to nil
    dst.RentAdvert = nil
    dst.SellAdvert = nil

    return fmt.Errorf("Data matches more than one schema in oneOf(Advert)")
    } else if match == 1 {
    return nil // exactly one match
    } else { // no match
    return fmt.Errorf("Data failed to match schemas in oneOf(Advert)")
    }
    }

    // strict decoder wrapper
    func newStrictDecoder(data []byte) *json.Decoder {
    dec := json.NewDecoder(bytes.NewBuffer(data))
    dec.DisallowUnknownFields()
    return dec
    }


    var _ json.Unmarshaler = (*{{ .Name }})(nil)
{{ end -}}